# AEGIS - System Design Document

## 1. Architecture Overview
AEGIS is a Client-Side Single Page Application (SPA) built with React. It leverages the Google Gemini API for intelligence and Three.js for visualization. It follows a modular architecture where the UI, 3D Engine, and AI Services are decoupled.

## 2. Technology Stack
*   **Frontend Framework:** React 19
*   **Build Tool:** Vite (implied by ESM imports)
*   **Styling:** Tailwind CSS (Utility-first), Lucide React (Icons)
*   **3D Engine:** Three.js, React Three Fiber, React Three Drei
*   **AI Integration:** Google GenAI SDK (`@google/genai`) - Model: `gemini-3-pro-preview`
*   **Visualization:** Recharts (Radar charts)
*   **State Management:** React Hooks (`useState`, `useEffect`, `useRef`)
*   **Storage:** LocalStorage (Primary), Supabase (Optional Cloud)

## 3. Component Architecture

### 3.1. Core Application (`App.tsx`)
*   Acts as the central controller.
*   Manages global state: `input`, `isAnalyzing`, `result`, `history`, `envConditions`.
*   Orchestrates the workflow: Input -> Environment Config -> 3D Modeling -> Analysis -> Result Display.

### 3.2. 3D Modeling Module (`components/ModelEditor.tsx`)
*   **Canvas:** Renders the 3D scene.
*   **Modes:**
    *   *Manual:* Renders a single `PrototypeMesh` based on slider inputs.
    *   *Blueprint:* Renders a collection of `PrimitiveMesh` objects generated by AI.
*   **Interactivity:** Uses `TransformControls` for manipulating objects and `OrbitControls` for camera movement.
*   **State:** Maintains an internal history stack for Undo/Redo functionality.

### 3.3. Analysis & Visualization
*   **`components/AnalysisDisplay.tsx`:** Consumes the `AnalysisResult` object. Renders the Risk Gauge, Radar Chart, and Markdown content. Handles file export.
*   **`components/PipelineVisualizer.tsx`:** Provides visual feedback during the asynchronous AI analysis phase (simulating a multi-step process).

### 3.4. Cloud Infrastructure (`components/CloudConnect.tsx`)
*   Provides a UI for users to input Supabase credentials.
*   Validates connection and toggles the application's storage mode.

## 4. Data Models (`types.ts`)

### 4.1. Analysis Result Schema
The core data structure returned by the AI:
```typescript
interface AnalysisResult {
  summary: string;
  riskScore: number;
  verdict: 'FEASIBLE' | 'PLAUSIBLE' | 'IMPLAUSIBLE' | 'IMPOSSIBLE';
  domain: PhysicsDomain;
  scores: { physics: number; engineering: number; economics: number; safety: number };
  componentBreakdown: string[];
  appliedPhysicsLaws: string[];
  keyCalculations: string[];
  manufacturability: { rating: string; assessment: string };
  violatedConstraints: string[];
  failureModes: { scenario: string; probability: string; impact: string; mitigation?: string }[];
  optimizations: string[];
  reasoning: string;
}
```

### 4.2. Blueprint Schema
The structure for 3D generation:
```typescript
interface BlueprintPart {
  id: string;
  type: 'box' | 'cylinder' | 'sphere' | 'cone' | 'capsule';
  position: [number, number, number];
  rotation: [number, number, number];
  scale: [number, number, number];
  color: string;
  name: string;
}
```

## 5. Service Layer

### 5.1. Gemini Service (`services/gemini.ts`)
*   **Prompt Engineering:**
    *   Constructs a massive system prompt containing the user's idea, selected domain, and environmental variables.
    *   Enforces a "Calibration Instruction" to prioritize user input over default slider values.
    *   Injects a strict JSON Schema to ensure the LLM output matches the TypeScript interfaces.
*   **Resilience:** Implements `executeWithRetry` logic. It maintains an array of API keys and automatically rotates to the next key if a rate limit (429) is encountered.

### 5.2. Storage Service (`services/storage.ts`)
*   **Abstraction:** Provides a unified interface (`saveItem`, `getHistory`) that handles data routing.
*   **Logic:**
    *   Always saves to LocalStorage for redundancy.
    *   If Supabase client is initialized (Cloud Enabled), it pushes/pulls data from the remote SQL table `simulations`.

## 6. UX/UI Design System
*   **Theme:** "Dark Engineering Console".
*   **Colors:**
    *   Background: `slate-950` (Deep Space).
    *   Primary Accent: `cyan-500` (Holographic Blue).
    *   Secondary Accent: `indigo-500`.
    *   Status Colors: Green (Feasible), Red (Impossible/Error), Yellow (High Risk).
*   **Typography:**
    *   Headings/Labels: `JetBrains Mono` (Technical feel).
    *   Body: `Inter` (Readability).
*   **Animations:** CSS Keyframes for `fade-in`, `pulse`, and `spin` to indicate system activity.

## 7. Data Flow
1.  **Input:** User enters text + Configures Env + (Optional) Generates 3D Model.
2.  **Request:** `App.tsx` calls `analyzeIdea` in `gemini.ts`.
3.  **Processing:**
    *   Prompt is constructed with all context.
    *   Gemini API processes request using `gemini-3-pro-preview`.
4.  **Response:** JSON is returned, parsed, and validated.
5.  **State Update:** `App.tsx` updates `result` state.
6.  **Persistence:** Result is passed to `StorageService` for saving.
7.  **Rendering:** `AnalysisDisplay` renders the data visualizations.
